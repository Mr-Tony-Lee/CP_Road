# Rod Cutting Solver using Dynamic Programming

這份程式碼實作了 **動態規劃 (Dynamic Programming, DP)** 來解決 **鋼條切割問題 (Rod Cutting Problem)**。

## 程式架構

程式主要由 `main.cpp` 組成，包含鋼條切割的最佳化演算法實作與解的重建。

### 1. 演算法概念

鋼條切割問題的目標是將一段長度為 $n$ 的鋼條切割成若干段，使得切割後的總價格最大。
給定一個價格表 $p$，其中 $p[i]$ 代表長度為 $i$ 的鋼條價格。

### 2. 資料結構

*   **`vector<int> p`**: 價格表。`p[i]` 為長度 `i` 的鋼條價格。
*   **`vector<int> r`**: 收益表格 (Revenue)。`r[j]` 儲存長度為 `j` 的鋼條所能獲得的最大收益。
*   **`vector<int> s`**: 切割點表格 (Solution)。`s[j]` 記錄了長度為 `j` 的鋼條在最佳解中的第一段切割長度。

### 3. 核心函式

#### `CutRod(vector<int>& p, int n)`
*   **初始化**: 建立大小為 `n+1` 的 `r` 與 `s` 表格，初始化為 0。
*   **狀態轉移 (Bottom-Up)**:
    *   外層迴圈 `j` 代表當前要計算的鋼條長度 (從 1 到 `n`)。
    *   內層迴圈 `i` 代表第一段切割的長度 (從 1 到 `j`)。
    *   對於每個長度 `j`，嘗試所有可能的切割點 `i`：
        *   計算收益 $q = p[i] + r[j-i]$。
        *   若 $q$ 大於目前的最大收益，則更新 `r[j]` 並記錄第一段長度 `s[j] = i`。
*   **輸出**: 印出最大收益 `r[n]`，並呼叫 `print_cut_rod_solution` 印出具體的切割方式。

#### `print_cut_rod_solution(vector<int>& s, int n)`
*   利用 `s` 表格重建最佳切割方案。
*   當剩餘長度 `n > 0` 時：
    *   印出第一段長度 `s[n]`。
    *   更新剩餘長度 `n = n - s[n]`。
    *   重複此步驟直到 `n` 為 0。

#### `main()`
*   定義範例價格表 `p = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30}`。
*   設定目標長度 `n = 7`。
*   呼叫 `CutRod` 進行計算。

## 使用方式

本專案包含 `Makefile`，可直接使用 `make` 指令編譯並執行。

```bash
make all
# 或者手動編譯與執行
# g++ -O3 main.cpp -o main
# ./main
```

程式執行後會輸出長度為 7 的鋼條之最大收益以及對應的切割長度組合。
