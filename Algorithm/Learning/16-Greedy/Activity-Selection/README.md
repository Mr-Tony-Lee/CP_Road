# Activity Selection Problem Solver

這份程式碼實作了 **活動選擇問題 (Activity Selection Problem)** 的多種解法，包含 **動態規劃 (Dynamic Programming)** 與 **貪婪演算法 (Greedy Algorithm)**。

## 程式架構

程式主要針對同一組活動數據，使用不同的演算法策略進行求解並比較結果。

### 1. 資料結構

*   **`vector<pair<int,int>> arr`**: 儲存所有活動的開始與結束時間。
    *   `first`: 開始時間 (Start Time)。
    *   `second`: 結束時間 (Finish Time)。

### 2. 核心函式與演算法

#### `solve_DP()` - 區間動態規劃 (Interval DP)
*   **時間複雜度**: $O(N^3)$
*   **方法**: 使用二維陣列 `dp[i][j]` 記錄在活動 `i` 結束後到活動 `j` 開始前，最多能選擇的活動數量。
*   **邏輯**: 
    *   加入虛擬的起始活動 `(0,0)` 與結束活動 `(INT_MAX, INT_MAX)`。
    *   枚舉區間長度 `L` 與起點 `i`，並在區間 `(i, j)` 內枚舉分割點 `k`。
    *   若活動 `k` 與 `i`, `j` 不衝突，則 `dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)`。

#### `solve_linear_dp()` - 線性動態規劃 (Linear DP)
*   **時間複雜度**: $O(N^2)$
*   **方法**: 類似最長遞增子序列 (LIS) 的思路。
*   **邏輯**:
    *   `dp[i]` 代表以「第 `i` 個活動」為結尾時，最多能選取的活動數。
    *   對於每個活動 `i`，檢查所有在其之前的活動 `j`。
    *   若活動 `j` 的結束時間小於活動 `i` 的開始時間（不衝突），則嘗試更新 `dp[i] = max(dp[i], dp[j] + 1)`。

#### `solve_greedy()` - 貪婪演算法 (Greedy Algorithm)
*   **時間複雜度**: $O(N \log N)$ (主要來自排序)
*   **方法**: 經典的貪婪策略。
*   **邏輯**:
    1.  將所有活動依照 **結束時間 (Finish Time)** 由小到大排序。
    2.  選擇第一個結束的活動。
    3.  依序檢查後續活動，若下一個活動的開始時間大於等於目前已選活動的結束時間，則選取該活動並更新結束時間。
    4.  此方法已被證明可得到全域最佳解。

#### `cmp()` - 比較函式
*   用於 `sort` 函式，將活動依照 **結束時間** 進行升冪排序。若結束時間相同，則依開始時間排序。

#### `main()` - 主流程
1.  從 `input.txt` 讀取活動數量 `N` 與每個活動的時間。
2.  對活動進行排序 (這是 Greedy 的必要步驟，也方便 DP 處理)。
3.  依序呼叫三種解法並輸出結果。

## 使用方式

### 1. 準備輸入檔案
請確認目錄下有 `input.txt` 檔案，格式如下：
```text
N
s1 f1
s2 f2
...
sN fN
```
*   `N`: 活動總數
*   `si fi`: 第 `i` 個活動的開始與結束時間

### 2. 編譯與執行
使用 `make` 指令即可自動編譯並執行：

```bash
make all
```

或者手動編譯：

```bash
g++ -O3 main.cpp -o main
./main
```

程式將會輸出三種方法計算出的最大活動數量。
