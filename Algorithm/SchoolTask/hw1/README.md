# TSP Solver using Brute Force

這份程式碼實作了 **暴力列舉法 (Brute Force)** 來解決 **旅行推銷員問題 (Traveling Salesman Problem, TSP)**。這是一種最直觀但效率最低的方法，它會嘗試所有可能的路徑組合，從中找出最短的一條。

## 程式架構

程式主要由 `TSP` 類別組成，封裝了所有與 TSP 相關的資料與操作。

### 1. 資料結構 (`class TSP`)

*   **成員變數**:
    *   `filename`: 輸入檔案名稱。
    *   `arr`: 儲存所有城市的座標 `(x, y)`。
    *   `point_dis`: 城市間的距離矩陣 (Distance Matrix)。
    *   `N`: 城市總數。
    *   `final_distance`: 計算出的最短路徑長度。
    *   `ans_point`: 儲存最短路徑的城市順序。

### 2. 核心函式

#### `init()` / `file_in()` - 初始化與讀檔
*   讀取城市座標。
*   計算所有城市間的歐幾里得距離，建立 `point_dis` 矩陣。

#### `solve_tsp()` - 主流程 (Brute Force Algorithm)
這是程式的核心，利用全排列來求解 TSP。

*   **演算法步驟**:
    1.  **產生初始排列**: 建立一個包含所有城市索引的陣列 `indices` (例如 `[1, 2, 3, ..., N]`)。
    2.  **全排列迴圈**: 使用 C++ 標準函式庫的 `next_permutation` 函式，依序產生所有可能的城市排列順序。
    3.  **計算路徑長度**: 對於每一個排列：
        *   計算相鄰城市間的距離總和。
        *   加上最後一個城市回到第一個城市的距離。
    4.  **更新最佳解**: 如果當前排列的路徑長度小於目前記錄的最小值，則更新最小值並記錄該路徑。

#### `plot()` - 繪圖
*   使用 `gnuplot` 將計算出的最佳路徑繪製成 PNG 圖片 (`fig_filename.png`)。

### 3. 複雜度分析

*   **時間複雜度**: $O(N!)$。
    *   $N$ 個城市的全排列總數為 $N!$ (階乘)。
    *   對於每個排列，計算路徑長度需要 $O(N)$ 的時間。
    *   總複雜度為 $O(N \cdot N!)$，這是一個非常巨大的數字。
    *   例如：$10! \approx 3.6 \times 10^6$，但 $20! \approx 2.4 \times 10^{18}$。
    *   因此，此方法僅適用於極小規模的問題 (例如 $N \le 10$)。
*   **空間複雜度**: $O(N^2)$。
    *   主要用於儲存距離矩陣 `point_dis`。

## 使用方式

```bash
g++ -o submit class_version.cpp
./submit point1.txt point2.txt ...
```

程式會輸出每個測試資料的最短路徑長度，並生成路徑圖。

## 優缺點

*   **優點**: 保證找到全域最佳解 (Global Optimum)，實作非常簡單。
*   **缺點**: 效率極低，隨著城市數量增加，執行時間呈指數級爆炸成長，無法處理實際規模的問題。
