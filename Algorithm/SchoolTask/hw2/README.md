# TSP Solver using Nearest Neighbor Heuristic

這份程式碼實作了 **最近鄰居法 (Nearest Neighbor Heuristic)** 來解決 **旅行推銷員問題 (Traveling Salesman Problem, TSP)**。這是一種 **貪婪演算法 (Greedy Algorithm)**，雖然不能保證找到全域最佳解，但計算速度快，適合處理大規模問題或作為其他演算法的初始解。

## 程式架構

程式主要由 `TSP` 類別組成，封裝了所有與 TSP 相關的資料與操作。

### 1. 資料結構 (`class TSP`)

*   **成員變數**:
    *   `filename`: 輸入檔案名稱。
    *   `arr`: 儲存所有城市的座標 `(x, y)`。
    *   `point_dis`: 城市間的距離矩陣 (Distance Matrix)。
    *   `N`: 城市總數。
    *   `final_distance`: 計算出的路徑長度。
    *   `ans_point`: 儲存最佳路徑的城市順序。

### 2. 核心函式

#### `init()` / `file_in()` - 初始化與讀檔
*   讀取城市座標。
*   計算所有城市間的歐幾里得距離，建立 `point_dis` 矩陣。

#### `solve_tsp()` - 主流程 (Nearest Neighbor Algorithm)
這是程式的核心，利用貪婪策略求解 TSP。

*   **演算法步驟**:
    1.  **嘗試所有起點**: 為了避免因起點選擇不佳而陷入局部最優，程式會嘗試將每一個城市都作為起點。
    2.  **貪婪選擇**:
        *   從當前城市出發。
        *   在所有**未訪問**的城市中，尋找距離當前城市**最近**的一個。
        *   移動到該城市，並將其標記為已訪問。
        *   重複此步驟，直到所有城市都被訪問過。
    3.  **回到起點**: 最後將最後一個訪問的城市連回起點，形成迴路。
    4.  **更新最佳解**: 比較不同起點所產生的路徑總長度，保留最短的那一條作為最終答案。

#### `plot()` - 繪圖
*   使用 `gnuplot` 將計算出的最佳路徑繪製成 PNG 圖片 (`fig_filename.png`)。

### 3. 複雜度分析

*   **時間複雜度**: $O(N^3)$。
    *   外層迴圈嘗試 $N$ 個起點。
    *   內層迴圈每次尋找最近鄰居需要遍歷剩餘的城市，約為 $O(N)$，共需找 $N$ 次，所以單次路徑建構為 $O(N^2)$。
    *   總共 $N \times N^2 = N^3$。
    *   (註：若不嘗試所有起點，僅從固定一點出發，複雜度為 $O(N^2)$)。
*   **空間複雜度**: $O(N^2)$。
    *   主要用於儲存距離矩陣 `point_dis`。

## 使用方式

```bash
g++ -o submit class_version.cpp
./submit point1.txt point2.txt ...
```

程式會輸出每個測試資料的路徑長度，並生成路徑圖。

## 優缺點

*   **優點**: 實作簡單、執行速度快。
*   **缺點**: 容易陷入局部最佳解 (Local Optimum)，通常找到的路徑比最佳解長 15%~25% 左右。
