# LeetCode 3625. Count Number of Trapezoids II

## 1. 核心數學概念：幾何與斜率

我們的目標是計算由給定點集組成的「嚴格梯形」數量。嚴格梯形定義為只有一組對邊平行的四邊形。

- **梯形 (Trapezoid)**：至少有一組對邊平行。
- **平行四邊形 (Parallelogram)**：兩組對邊皆平行（對角線互相平分）。
- **嚴格梯形** = 所有梯形 - 平行四邊形。

## 2. 解題策略：斜率分組與中點性質

我們遍歷所有點對，計算每對點形成的線段的「斜率」與「中點」。

### 步驟一：計算所有梯形（包含平行四邊形）
兩條線段若斜率相同且不共線（截距不同），則它們平行，可以組成一個梯形（或平行四邊形）。
我們使用 Hash Map `slopeToIntercept` 記錄 `{斜率 : [截距列表]}`。
對於同一個斜率，若有不同的截距 $b_1, b_2, \dots$，則截距為 $b_i$ 的線段數量為 $count_i$。
能組成的梯形數量為 $\sum count_i \times count_j$ (其中 $i \neq j$)。

### 步驟二：扣除平行四邊形
平行四邊形的對角線互相平分。這意味著如果兩條線段共享同一個中點，則它們的端點構成一個平行四邊形。
我們使用 Hash Map `midToSlope` 記錄 `{中點 : [斜率列表]}`。
對於同一個中點，若有不同的斜率 $k_1, k_2, \dots$，則它們對應的線段組成平行四邊形。
我們需要從總數中扣除這些組合。

### 數學公式
- 斜率 $k = \frac{y_1 - y_2}{x_1 - x_2}$
- 截距 $b$ (或是直線方程式 $Ax + By + C = 0$)
- 中點 $Mid = (x_1+x_2, y_1+y_2)$ (為避免浮點數，可存兩倍座標或 hash 值)

## 3. 實作細節與誤差處理：截距計算

在計算截距 $b$ 時，直接使用 $b = y_1 - k \times x_1$ 會導致嚴重的浮點數誤差。

### 為什麼會出錯？
1. **誤差放大**：斜率 $k = \frac{dy}{dx}$ 本身可能是一個無限循環小數，帶有微小誤差。當這個誤差乘以較大的座標值 $x_1$ 時，誤差會被顯著放大。
2. **Hash Map 失效**：在 `unordered_map` 中，即使是極微小的浮點數差異也會被視為不同的 key，導致本應共線的點被判定為不同直線。

### 修正後的公式
為了減少誤差，我們應盡量延後除法運算的時間點：
$$
b = y_1 - \frac{dy}{dx} x_1 = \frac{y_1 dx - x_1 dy}{dx}
$$
程式碼實作：
```cpp
// 避免直接使用 b = y1 - k * x1
b = (double)(1LL * y1 * dx - 1LL * x1 * dy) / dx;
```
這樣分子部分 `(y1 * dx - x1 * dy)` 會先以整數進行精確運算，最後才除以 `dx` 轉為浮點數，能大幅降低誤差。

## 4. 實作細節：中點的 Hash 處理

在程式碼中，我們看到中點的計算方式如下：
```cpp
int mid = (x1 + x2) * 10000 + (y1 + y2);
```

### 為什麼這樣算？

1.  **避免浮點數**：
    真正的中點座標是 $(\frac{x_1+x_2}{2}, \frac{y_1+y_2}{2})$。
    為了避免浮點數運算帶來的誤差與麻煩，我們直接儲存 **兩倍的中點座標**，即 $(x_1+x_2, y_1+y_2)$。只要兩條線段的 $(x_1+x_2, y_1+y_2)$ 相同，它們的中點就相同。

2.  **二維座標轉一維 Key (Coordinate Compression)**：
    為了將 $(X_{sum}, Y_{sum})$ 這個二維資訊作為 `unordered_map` 的 key，我們將其壓縮成一個整數。
    公式：`Key = X_sum * Constant + Y_sum`
    這裡選用 `10000` 作為常數（假設題目座標範圍使得 $y_1+y_2 < 10000$），這就像是將座標看作一個 **10000 進位** 的數字。
    - 高位數儲存 $X$ 座標總和。
    - 低位數儲存 $Y$ 座標總和。
    這樣可以保證每個不同的 $(X_{sum}, Y_{sum})$ 對應到唯一的整數 key（在座標範圍允許的情況下）。
