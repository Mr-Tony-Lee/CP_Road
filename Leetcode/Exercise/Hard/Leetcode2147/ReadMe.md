# LeetCode 2147. Number of Ways to Divide a Long Corridor

## 1. 題目重述
給定一條走廊字串 `corridor`，其中每個字元為：
- `S` 表示座位（seat）
- `P` 表示植物（plant）

你可以在字元之間放置隔板，將走廊切分成若干區段。每個區段都必須包含「恰好兩個座位」，植物數量不限。請問共有多少種切分方式（答案需取模 `1e9+7`）。若無法切分（例如座位總數為奇數或少於 2），則回傳 0。

## 2. 核心概念
- 區段劃分：每個區段必須剛好含 2 個 `S`。
- 乘法原理：不同區段的切分選擇相互獨立，總數為各段可切位置數的乘積。
- 模運算：結果需取模 `1e9+7`。

## 3. 解題策略

想法：將整條走廊依「座位」分段。每當累積到第 2 個座位，就開始計算下一個座位出現前（也就是第 3 個座位到來前）有多少個植物 `P`。假設在兩段「座位對」之間共有 `p` 個植物，則可以在它們之間選擇 `p+1` 個位置放隔板（包含兩端）。整體答案為所有這樣的 `p+1` 的乘積。

步驟：
1. 線性掃描 `corridor`，累計座位數 `s` 與中間植物數 `p`。
2. 當 `s` 為偶數且不為 0（介於第 2 與第 3、第 4 與第 5 ... 個座位之間），遇到 `P` 時累計 `p`。
3. 每當 `s` 變成奇數（例如到第 3、5、7... 個座位），代表剛結束一段「座位對 → 下一座位」的區間，將答案乘上 `p+1`，並重置 `p = 0`。
4. 掃描結束後，若座位總數為奇數或少於 2，回傳 0；否則回傳累積結果。

此策略對應到乘法原理：每一段的切分數為該段的 `p+1`，總答案為各段乘積。

## 4. 複雜度分析
- 時間複雜度：O(n)，單次線性掃描字串長度 `n`。
- 空間複雜度：O(1)，只使用常數額外變數。

## 5. 參考實作（C++）
- 程式檔：`Leetcode2147.cpp`（同資料夾）

## 6. 注意與邊界情況
- 座位總數為奇數或少於 2 時，答案為 0。
- 連續多段座位對之間的植物數可能為 0；其對應的可切位置數為 `0+1 = 1`（不影響乘積）。
- 需對結果取模 `1e9+7`，避免溢位。

## 7. 動態規劃（Bottom-up）
雖然本題以乘法原理線性掃描即可，但也能用自底向上的 DP 做為等價解法，幫助理解狀態轉移。

- 狀態定義：`count[i][s]` 表示「從索引 i 到字串末端」的切分方式數，其中當前區段已累計 `s` 個座位（`s ∈ {0,1,2}`）。
- 基底：令 `n = corridor.length`
	- `count[n][0] = 0`
	- `count[n][1] = 0`
	- `count[n][2] = 1`（走到結尾且剛好有 2 個座位，視為一種合法完成）
- 轉移（自 i = n-1 遞減到 0）：
	- 若 `corridor[i] == 'S'`：
		- `count[i][0] = count[i+1][1]`
		- `count[i][1] = count[i+1][2]`
		- `count[i][2] = count[i+1][1]`
	- 若 `corridor[i] == 'P'`：
		- `count[i][0] = count[i+1][0]`
		- `count[i][1] = count[i+1][1]`
		- `count[i][2] = (count[i+1][0] + count[i+1][2]) % MOD`（`MOD = 1e9+7`）
- 答案：`count[0][0]`。

直覺說明：`s` 代表目前區段已收集的座位數，當 `s = 2` 時，遇到植物 `P` 可選擇「延續同一段」或「在此處切分到下一段」，因此有兩個來源；而遇到座位 `S` 則會把下一狀態導向 `s = 1`（表示下一段已開始累計 1 個座位）。此 DP 與乘法原理的「每段有 `p+1` 個切點」本質相同。

複雜度：
- 時間：O(n)
- 空間：O(n)（可進一步滾動陣列降至 O(1)）

