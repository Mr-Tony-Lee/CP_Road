# LeetCode 3531. Count Covered Buildings

## 1. 題目重述
給定一個正整數 `n` 和一個二維陣列 `buildings`，其中 `buildings[i] = [x, y]` 代表在座標 `(x, y)` 上有一棟建築物。所有建築物的座標都在一個 `n × n` 的網格上，且每個座標都是唯一的。

一棟建築物被認為是「被覆蓋的」(covered)，如果在它的同一行 (row) 和同一列 (column) 上都存在至少一棟其他建築物。更具體地說，座標 `(x, y)` 上的建築物被覆蓋當且僅當：
- 存在至少一棟建築物在座標 `(x', y)` 上，其中 `x' < x`
- 存在至少一棟建築物在座標 `(x'', y)` 上，其中 `x'' > x`
- 存在至少一棟建築物在座標 `(x, y')` 上，其中 `y' < y`
- 存在至少一棟建築物在座標 `(x, y'')` 上，其中 `y'' > y`

回傳被覆蓋的建築物總數。

## 2. 核心概念
- 座標邊界追蹤：記錄每個行和列的最小/最大座標
- 條件判斷：檢查建築物是否同時被四個方向的其他建築物包圍

## 3. 解題策略

步驟：

1. 為每一行 (y 座標) 維護該行上所有建築物的最小和最大 x 座標：`minX[y]` 和 `maxX[y]`
2. 為每一列 (x 座標) 維護該列上所有建築物的最小和最大 y 座標：`minY[x]` 和 `maxY[x]`
3. 遍歷所有建築物，預處理上述四個陣列
4. 再次遍歷所有建築物 `(x, y)`，檢查是否滿足：
   - `minX[y] < x < maxX[y]`（在同一行上左右都有建築物）
   - `minY[x] < y < maxY[x]`（在同一列上上下都有建築物）
5. 統計滿足條件的建築物數量

此方法透過預處理每行每列的邊界，可以在 O(1) 時間內判斷每棟建築物是否被覆蓋。

### 範例說明

假設 `n = 4`，`buildings = [[1,1], [2,2], [3,1], [2,3], [1,3]]`：
- 行 y=1：建築物在 x=1,3，所以 minX[1]=1, maxX[1]=3
- 行 y=2：建築物在 x=2，所以 minX[2]=2, maxX[2]=2
- 行 y=3：建築物在 x=1,2，所以 minX[3]=1, maxX[3]=2
- 列 x=1：建築物在 y=1,3，所以 minY[1]=1, maxY[1]=3
- 列 x=2：建築物在 y=2,3，所以 minY[2]=2, maxY[2]=3
- 列 x=3：建築物在 y=1，所以 minY[3]=1, maxY[3]=1

檢查 `(2,2)`：
- minX[2]=2, maxX[2]=2，不滿足 `2 < 2 < 2`，所以不被覆蓋

檢查其他建築物可以類似判斷。

## 4. 複雜度分析
- 時間複雜度：O(m)，其中 m 是建築物的數量。需要遍歷兩次建築物陣列，一次預處理邊界，一次檢查覆蓋條件。
- 空間複雜度：O(n)，需要維護四個大小為 n+1 的陣列來存儲每行每列的邊界資訊。

## 5. 參考實作（C++）
- 程式檔：[Leetcode3531.cpp](Leetcode3531.cpp)（同資料夾）

## 6. 注意與邊界情況
- 建築物數量可能很少，大部分或全部建築物都不被覆蓋
- 邊界建築物（位於某行或某列的最邊緣）永遠不會被覆蓋
- 需要初始化 minX 和 minY 為足夠大的值（n+1），maxX 和 maxY 為 0
- 每個座標只會有一棟建築物（題目保證座標唯一）
