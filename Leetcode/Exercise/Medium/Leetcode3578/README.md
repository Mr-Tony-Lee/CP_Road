# LeetCode 3578. Count Partitions With Max-Min Difference at Most K

## 1. 題目解釋

題目要求我們將陣列 `nums` 分割成一個或多個非空的連續子陣列，使得在每個子陣列中，最大元素與最小元素的差值不超過 `k`。
我們需要計算所有符合條件的有效分割方案總數。

## 2. 解題思路

這道題可以使用 **動態規劃 (Dynamic Programming)** 結合 **滑動窗口 (Sliding Window)** 來解決。

### 核心狀態定義

定義 `dp[i+1]` 為前綴 `nums[0...i]` 的有效分割方案數。
- 基本情況：`dp[0] = 1` (空前綴視為一種有效情況)。
- 轉移方程：
  $$
  dp[i+1] = \sum dp[j]
  $$
  其中 `j` 是最後一個子陣列的起始位置，且 `nums[j...i]` 滿足最大最小差值 $\le k$。

### 優化策略

直接枚舉所有合法的 `j` 會導致 $O(N^2)$ 的時間複雜度。我們觀察到，對於固定的右端點 `i`，合法的左端點 `j` 會形成一個連續區間 $[L, i]$。
只要 `nums[L...i]` 的極差 $\le k$，那麼對於任何 $j \in [L, i]$，`nums[j...i]` 的極差也一定 $\le k$。

因此，我們可以利用 **前綴和** 來優化 DP 轉移：
令 `prefix[x]` 為 `dp` 陣列的前綴和，即 `prefix[x] = dp[0] + ... + dp[x-1]`。
則：
$$
dp[i+1] = prefix[i+1] - prefix[L]
$$
*(註：這裡的索引需根據具體實作調整，概念上是區間和)*

### 尋找左邊界 L

我們需要找到最小的索引 `L`，使得 `nums[L...i]` 的極差 $\le k$。這是一個經典的滑動窗口問題。
我們可以使用以下兩種資料結構來維護窗口內的最大值與最小值：

1.  **有序集合 (Ordered Set / Multiset)**：
    -   插入與刪除操作為 $O(\log N)$。
    -   總時間複雜度：$O(N \log N)$。

2.  **單調隊列 (Monotonic Queue)**：
    -   維護兩個單調隊列，一個遞增（維護最小值），一個遞減（維護最大值）。
    -   均攤操作為 $O(1)$。
    -   總時間複雜度：$O(N)$。

## 3. 複雜度分析

-   **時間複雜度**：$O(N)$ (若使用單調隊列) 或 $O(N \log N)$ (若使用有序集合)。
-   **空間複雜度**：$O(N)$，用於存儲 DP 陣列、前綴和陣列以及滑動窗口的資料結構。
