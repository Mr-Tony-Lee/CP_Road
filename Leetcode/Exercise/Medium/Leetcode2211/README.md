# LeetCode 2211. Count Collisions on a Road

## 1. 核心思維：碰撞條件與狀態機

我們的目標是計算在道路上發生的總碰撞次數。車輛有三個狀態：`L` (向左), `R` (向右), `S` (靜止)。

碰撞發生的情況：
1. `R` 撞上 `L`：發生 2 次碰撞，兩者皆變 `S`。
2. `R` 撞上 `S`：發生 1 次碰撞，`R` 變 `S`。
3. `S` 撞上 `L` (即 `L` 撞上 `S`)：發生 1 次碰撞，`L` 變 `S`。

**關鍵觀察：**
- 任何 `R` 只要右邊有 `S` 或 `L`，最終都會撞停。
- 任何 `L` 只要左邊有 `S` 或 `R`，最終都會撞停。
- 只有 **最左邊連續的 L** 和 **最右邊連續的 R** 永遠不會發生碰撞，其餘中間的車輛最終都會捲入碰撞。

## 2. 解題策略：線性掃描 (Linear Scan)

我們利用一個變數 `flag` 來追蹤左側的狀態，並遍歷字串 `directions`，模擬車輛的互動。

### 變數定義 `flag`
- `flag == -1`: **初始安全狀態**。表示左邊還沒有任何障礙物（沒有 `R` 也沒有 `S`）。此時遇到的 `L` 都會安全離開。
- `flag == 0`: **靜止障礙狀態**。表示左邊已經有「靜止」的車輛（原本的 `S` 或已相撞形成的車堆）。
- `flag > 0`: **累積 R 狀態**。表示左邊累積了 `flag` 輛向右行駛的 `R`，它們還沒撞到東西，正在等待右邊的障礙。

### 演算法流程
遍歷每個車輛 `c`：

1. **遇到 `L` (向左車)**：
   - 若 `flag >= 0` (左邊有 `R` 或 `S`)：
     - 發生碰撞！
     - 碰撞次數 `res += flag + 1`。
       - `flag`：代表累積的那些 `R` 全部撞上來。
       - `1`：代表當前的 `L` 也撞停。
     - 狀態更新為 `flag = 0` (形成新的靜止車堆)。
   - 若 `flag == -1`：這輛 `L` 安全開走，不計入碰撞。

2. **遇到 `S` (靜止車)**：
   - 若 `flag > 0` (左邊有 `R`)：
     - 發生碰撞！
     - 碰撞次數 `res += flag` (所有累積的 `R` 撞上這個 `S`)。
   - 狀態更新為 `flag = 0` (現在這裡是靜止障礙物)。

3. **遇到 `R` (向右車)**：
   - 累積向右的車輛。
   - 若 `flag >= 0`，則 `flag++`。
   - 若 `flag == -1`，則 `flag = 1` (開始累積)。

### 複雜度分析
- **時間複雜度**：$O(N)$，只需遍歷一次字串。
- **空間複雜度**：$O(1)$，僅使用常數個變數。
