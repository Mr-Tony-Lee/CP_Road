# LeetCode 3769. Sort Integers by Binary Reflection

## 1. 核心概念：位元操作與自定義排序

這道題目的核心在於如何定義一個新的排序規則。規則如下：
1.  首先比較元素的「位元反轉值」(Bitwise Reflection)。
2.  若位元反轉值相同，則比較元素的原始數值。

### 位元反轉 (Bit Reversal)
對於一個整數 $n$，我們需要將其二進位表示法進行反轉。
例如：
- $n = 6 (110_2) \rightarrow 3 (011_2)$
- $n = 10 (1010_2) \rightarrow 5 (0101_2)$

這可以透過迴圈不斷取出最低位元 ($n \% 2$ 或 $n \& 1$) 並加到結果的末尾 ($ans \times 2$ 或 $ans \ll 1$) 來實現。

## 2. 解題策略：轉換與排序 (Transform and Sort)

為了高效地進行排序，我們可以預先計算所有數字的位元反轉值，並將其與原始數值配對。

### 演算法步驟

1.  **定義反轉函數**：實作 `BitReverse` 函數，將輸入整數轉換為其位元反轉後的值。
    - 使用 `while(n > 0)` 迴圈。
    - 每次迭代：`ans = (ans << 1) + (n & 1)`，然後 `n >>= 1`。
2.  **建立配對陣列**：建立一個 `vector<pair<int, int>>`，其中每個元素為 `{反轉值, 原始值}`。
3.  **排序**：對配對陣列進行排序。
    - C++ 的 `std::sort` 對於 `pair` 預設會先比較 `first` (反轉值)。
    - 若 `first` 相同，則比較 `second` (原始值)。
    - 這完全符合題目的排序要求。
4.  **提取結果**：遍歷排序後的陣列，將 `second` (原始值) 取出放入結果陣列。

### 複雜度分析
- **時間複雜度**：$O(N \log N \cdot \log M)$
    - 計算 $N$ 個數字的反轉值需要 $O(N \log M)$，其中 $M$ 是數字的最大值（位元數）。
    - 排序需要 $O(N \log N)$。
    - 總體時間複雜度主要由排序決定。
- **空間複雜度**：$O(N)$
    - 需要額外的空間來儲存 `{反轉值, 原始值}` 的配對陣列。
