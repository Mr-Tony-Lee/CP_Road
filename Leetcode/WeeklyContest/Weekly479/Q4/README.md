# Leetcode 3772. Maximum Subgraph Score in a Tree

## 題目概念 (Intuition)
題目要求找出包含每個節點的連通子圖的最大可能分數。
每個節點的分數貢獻為 +1 (good) 或 -1 (bad)。

核心概念是將其視為 **樹形 DP (Tree DP)** 問題，並使用 **換根 DP (Rerooting Technique)**：

1.  **Bottom-up (Post-order) DP**: 
    對於每個節點，計算從其**子樹**（僅使用子節點）能獲得的最佳分數。我們只累積正的貢獻，並捨棄負的貢獻。
    
2.  **Top-down DP**: 
    在知道每個節點的子樹貢獻後，將**父節點**的貢獻傳遞給子節點。這樣每個節點都能知道包含它的最佳連通子圖分數（範圍可能向上延伸至父節點方向）。

這種兩次遍歷的 DP 方法讓我們能計算出每個節點的最佳連通子圖分數。

## 解題步驟 (Approach)

1.  **轉換數值 (Convert values)**
    將 `good` 陣列轉換為數值方便計算：
    *   good $\rightarrow$ +1
    *   bad $\rightarrow$ -1

2.  **建立鄰接表 (Build adjacency list)**
    使用鄰接表 (Adjacency List) 來表示樹的結構。

3.  **Bottom-up DFS (`dfsB`)**
    對於每個節點 $u$：
    *   從節點自身的值 (+1 或 -1) 開始。
    *   遞迴計算子節點的貢獻。
    *   只有當子節點的 DP 值為**正**時才加入（因為負值只會降低總分）。
    *   因此，`dp[u]` 代表以 $u$ 為根，且僅包含其子樹節點的連通子圖最佳分數。

4.  **Top-down DFS (`dfsT`)**
    進行換根 DP：
    *   對於每個子節點 $v$，計算當樹以 $v$ 為 "根" 時的最佳分數。
    *   來自父節點 $u$ 的貢獻 = `ans[u] - max(0, dp[v])` (即父節點的最佳解扣除掉 $v$ 貢獻的部分)。
    *   如果這個來自父節點的貢獻是正的，則加到 `dp[v]` 上形成 `ans[v]`。
    *   最終 `ans[i]` 即為包含節點 $i$ 的任意連通子圖的最大可能分數。

## 範例直覺 (Example Intuition)
*   如果子樹帶來負面影響，我們就直接排除它（不選該分支）。
*   如果父節點方向帶來正面價值，我們就包含它。
這確保了每個節點都能形成最佳的連通子圖。

## 複雜度分析 (Complexity)
*   **時間複雜度**: $O(n)$ — 一次 Bottom-up 遍歷加上一次 Top-down 遍歷。
*   **空間複雜度**: $O(n)$ — 用於鄰接表和 DP 陣列。
