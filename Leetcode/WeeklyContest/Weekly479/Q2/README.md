# LeetCode 3770. Largest Prime from Consecutive Prime Sum

## 1. 題目描述

給定一個整數 $n$，請找出小於等於 $n$ 的最大整數，該整數必須同時滿足以下兩個條件：
1. 該整數是一個質數。
2. 該整數是前 $k$ 個質數的總和（即質數數列的前綴和）。

如果不存在這樣的整數，則返回 0。

## 2. 解題策略

這道題目結合了**質數篩法 (Sieve of Eratosthenes)** 與 **前綴和 (Prefix Sum)** 的概念。

### 核心思路

1. **生成質數**：首先需要產生一系列的質數（2, 3, 5, 7, 11, ...）。
2. **計算前綴和**：計算這些質數的累加和（2, 2+3=5, 5+5=10, 10+7=17, ...）。
3. **質數判斷**：檢查這些前綴和本身是否也是質數。
4. **搜尋答案**：在所有符合條件（是質數且是前綴和）的數字中，找出小於等於 $n$ 的最大值。

### 實作方法

#### 方法一：直接模擬 (My Version)
- 使用篩法或簡單的質數判斷函數建立質數表。
- 遍歷質數表計算前綴和，若前綴和超過 $n$ 則停止。
- 對每個前綴和再次進行質數測試，若符合則更新最大值。

#### 方法二：預處理 + 二分搜尋 (Optimized Version)
- **預處理 (Precomputation)**：
  - 利用 `static` 區塊或 lambda 表達式在程式啟動時預先計算好一定範圍內的質數與前綴和。
  - 使用一個陣列 `primes` 標記數字是否為合數（例如設為 -1）。
  - 將所有計算出的前綴和存入 `std::set` 中，保證有序。
- **查詢 (Query)**：
  - 利用 `std::set::upper_bound(n)` 快速找到大於 $n$ 的第一個前綴和。
  - 向前移動迭代器，檢查該前綴和是否為質數（利用預處理的 `primes` 陣列快速判斷）。
  - 找到的第一個符合條件的數即為答案。

## 3. 複雜度分析

假設 $M$ 為預處理的範圍上限（例如前綴和上限），$Q$ 為查詢次數。

- **時間複雜度**：
  - 預處理：$O(M \log \log M)$ (埃氏篩法)。
  - 查詢：$O(\log S)$，其中 $S$ 是符合條件的前綴和數量。由於前綴和增長很快，數量 $S$ 遠小於 $M$。
- **空間複雜度**：
  - $O(M)$，用於存儲篩法陣列與前綴和集合。
