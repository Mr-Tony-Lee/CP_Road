#include<bits/stdc++.h>
using namespace std;


int main(){
    int n ;
    int coin[5] = {1,5,10,25,50};
    int dp[7500] = {};
    dp[0] = 1;
    for(int i = 0 ; i < 5 ; i++ ){
        for(int j = coin[i] ; j <= 7500 ; j++ ){
            dp[j] += dp[j-coin[i]];
        }
    }
    while(cin >> n){    // n no larger than 7489 
        cout << dp[n] << endl;
    }
}
/*
    解題說明 : 
        這題屬於要 dp 出所有組合，而邏輯就是，如果現在要算20塊錢的組合 就是 (20-5)塊錢的組合 + (20-10) + 所有都是1塊錢的組合 的組合，而如果這樣想的話，
        會重複算一個(10,5)的這個組合數，但如果寫在程式，可以解決這個問題。
        上方程式碼就是，20塊錢，我先把5塊錢拿出來，剩下15塊錢，但是15塊錢在跑用5塊錢組合的起來的時候，只有(5,5,5),(1,1,1,1,1,5,5)... 
        -> 不能用10塊(剛好與我們要的一樣，不會重複使用到10塊錢) ，所以這樣的結果就是在第一次迴圈遇到(20-5)塊錢的組合時，拿到的答案不是5，而是4，
        那再來，把10塊錢拿出來的時候，剩下10塊錢，也就只有(10),(5,5),(5,1,1,1,1),(1,1,1,1,1)，最後所有組合就是
        10塊錢的(4) + 5塊錢的(4) + 全部都1塊，剛好就找出所有的組合，所以最主要的是要從小的開始。

*/