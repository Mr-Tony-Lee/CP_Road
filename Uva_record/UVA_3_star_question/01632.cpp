#include<bits/stdc++.h>
using namespace std;

int a[10010];   // 寶藏的位置
int b[10010];   // 消失的時間
int dp[2][10010][2];

int main(){
    int n ; 
    // dp[i][j][0] 代表拿完區間 (i,j) 的所有寶藏，且最後位於 i
    // dp[i][j][1] 代表拿完區間 (i,j) 的所有寶藏，且最後位於 j 

    while(cin >> n ){
        int now = 0 ; 
        for(int i = 1 ; i <= n ; i++ ){
            cin >> a[i] >> b[i] ; 
        }
        for(int j = 1 ; j <= n ; j++ ){
            dp[0][j][0] = dp[0][j][1] = (b[j] > 0 ? 0 : (1<<30));
            // 如果 b[j] > 0，代表該位置的寶藏一開始還沒有消失，時間為 0（因為寶藏還沒被撿）。
            // 如果 b[j] ≤ 0，代表這個寶藏 一開始就已經消失，所以設定一個很大的數 (1 << 30)（代表不可能撿到）。
        }
        
        // dp[i][j][0] = min(dp[i+1][j][0] + a[i+1] - a[i] , dp[i+1][j][1] + a[j] - a[i]);
        // 區間 i 到 j 最後停在 i ， 所以，最短的路線就是 
        // 1. 上一次停在 i + 1 然後加上 (a[i+1]-a[i]) -> i+1 ~ i 的距離 ， i + 1 比較大 所以大減小 
        // 2. 上一次停在 區間 i+1 ~ j 停在 j ， 然後從 j 走到 i ，

        // dp[i][j][1] = min(dp[i][j-1][0] + a[j] - a[i] , dp[i][j-1][1] + a[j] - a[j-1]);
        // 區間 i 到 j 最後停在 j ， 所以，最短的路線就是 
        // 1. 上一次區間是 i~j-1，然後停在 i ， 下一次就是 從 i 走到 j， 所以加上 a[j]-a[i];
        // 2. 上一次區間是 i~j-1，然後停在 j-1 ， 下一次就是從 j-1 走到 j，所以加上 a[j]-a[j-1]
        
        // 那如果照上面的dp 會TLE 因為要 dp 完 10000 * 10000 次 ，所以做出優化，左端點是 j ， 右端點是 j + i ，
        // dp[now^1][j+1][0]代表的是 上一次是從 j+1 ~ j+i ， 最後停在j+1，
        // dp[now^1][j+1][1]代表的是 上一次是從 j+1 ~ j+i ， 最後停在j+i，
        // now^1 跟 now 的差距在於 i 差 1 ， 
        // dp[now][j][0] 則表示從 j 走到 j + i ， 最後停在 j 
        // dp[now][j][1] 則表示從 j 走到 j + i ， 最後停在 j + i
        // 所以 dp[now^1][j][0] + a[j+i] - a[j] ， 就是上次停在 j 然後這次要停在 j+i ， 所以是 a[j+i] - a[j]
        // dp[now^1][j][1] + a[j+i] - a[j+i-1] ， 就是上次停在 j+(i-1)->上次的 i  然後這次要停在 j+i ， 所以是 a[j+i] - a[j+(i-1)]
        // 最後判斷是否在時間範圍內，超過時間就賦值無限大

        for(int i = 1 ; i < n ; i++ ){
            now ^= 1 ;  // 因為我們只需要存上一層和當前層的資訊 ， 所以 now 在 0 跟 1 之間切換
            for(int j = 1 ; j <= n-i ; j++ ){   // i + j 是現在的位置，
                dp[now][j][0] = min(dp[now^1][j+1][0] + a[j+1] - a[j] , dp[now^1][j+1][1] + a[j+i] - a[j]);
                dp[now][j][1] = min(dp[now^1][j][0] + a[j+i] - a[j] , dp[now^1][j][1] + a[j+i] - a[j+i-1]);

                dp[now][j][0] = dp[now][j][0] < b[j] ? dp[now][j][0] : (1<<30);
                dp[now][j][1] = dp[now][j][1] < b[j+i] ? dp[now][j][1] : (1<<30);
            }
        }
        // 最後輸出 從 1 走到最後的最小值 ( 停在 1 或停在 j )
        int ans = min(dp[now][1][0] , dp[now][1][1]);

        if(ans == (1<<30)){
            cout << "No solution" << endl;
        }
        else{
            cout << ans << endl;
        }
    }
       
}